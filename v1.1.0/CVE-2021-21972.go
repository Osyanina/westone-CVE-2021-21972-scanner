package main

import (
	"bufio"
	"crypto/tls"
	"fmt"
	"net/http"
	"os"
	"regexp"
	"sync"
	"time"
)

var wg sync.WaitGroup

func duqu(file *os.File, targets chan string)  {
	m := bufio.NewScanner(file)
	for m.Scan() {
		target := fmt.Sprintf("%s", m.Text())
		targets <- target
	}
	err := m.Err()
	if err != nil {
		fmt.Println("错误")
	}
	close(targets)
	fmt.Println("读取完毕,即将开始批量化检测")
}

func jiance(targets chan string)  {
	for  {
		select {
		case target, ok := <-targets:
			if !ok {
				wg.Done()
				return
			}
			tr := &http.Transport{
				TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
			}
			t := &http.Client{Transport: tr}
			if isurl, _ := regexp.MatchString(`https://`, target); isurl == false{
				target = "https://" + target
			}
			p := "/ui/vropspluginui/rest/services/uploadova"
			var payload = fmt.Sprintf("%s%s", target, p)
			r, err := http.NewRequest("GET", payload, nil)
			r.Header.Set("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36")
			r.Header.Set("Content-Type", "application/x-www-form-urlencoded")
			if err != nil {
				fmt.Println("页面访问出错，请手动检查页面是否对外开放。")
			}
			r1, err := t.Do(r)
			if err != nil {
				fmt.Println("页面访问出错，请手动检查页面是否对外开放。")
			}
			if r1.StatusCode == 405 {
				fmt.Printf("[+]%s存在CVE-2021-21972漏洞\n", target)
			}else {
				fmt.Printf("[-]%s不存在CVE-2021-21972漏洞\n", target)
			}
			r1.Body.Close()
		case <- time.After(time.Duration(2) * time.Second):
			wg.Done()
			return
		}
	}
}

func main()  {
	fmt.Println(`
 __          __       _                   
 \ \        / /      | |                  
  \ \  /\  / /__  ___| |_ ___  _ __   ___ 
   \ \/  \/ / _ \/ __| __/ _ \| '_ \ / _ \
    \  /\  /  __/\__ \ || (_) | | | |  __/
     \/  \/ \___||___/\__\___/|_| |_|\___|

		磐石CVE-2021-21972漏洞扫描工具
		版本       1.1
		`)
	if len(os.Args) == 2 {
		tr := &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
		}
		t := &http.Client{Transport: tr}
		target := os.Args[1]
		if isurl, _ := regexp.MatchString(`https://`, target); isurl == false{
			target = "https://" + target
		}
		p := "/ui/vropspluginui/rest/services/uploadova"
		var payload = fmt.Sprintf("%s%s", target, p)
		r, err := http.NewRequest("GET", payload, nil)
		r.Header.Set("user-agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36")
		r.Header.Set("Content-Type", "application/x-www-form-urlencoded")
		if err != nil {
			fmt.Println("页面访问出错，请手动检查页面是否对外开放。")
		}
		r1, err := t.Do(r)
		if err != nil {
			fmt.Println("页面访问出错，请手动检查页面是否对外开放。")
		}
		if r1.StatusCode == 405 {
			fmt.Printf("[+]%s存在CVE-2021-21972漏洞\n", target)
		}else {
			fmt.Printf("[-]%s不存在CVE-2021-21972漏洞\n", target)
		}
		r1.Body.Close()
	}else if len(os.Args) == 3 {
		if os.Args[1] == "-f" {
			file, err := os.Open(os.Args[2])
			if err != nil {
				fmt.Println("文件打开失败: ", err)
				return
			}
			defer file.Close()
			targets := make(chan string)
			go duqu(file, targets)
			for i := 0; i < 200; i++ {
				wg.Add(1)
				go jiance(targets)
			}
			wg.Wait()
		}else {
			fmt.Println("格式输入错误，请输入要扫描的主机，例如:")
			fmt.Println("CVE-2021-21972.exe www.baidu.com")
			fmt.Println("CVE-2021-21972.exe 127.0.0.1:8080")
			fmt.Println("CVE-2021-21972.exe https://127.0.0.1:8080")
			fmt.Println("CVE-2021-21972.exe -f target.txt")
		}
	}else{
		fmt.Println("格式输入错误，请输入要扫描的主机，例如:")
		fmt.Println("CVE-2021-21972.exe www.baidu.com")
		fmt.Println("CVE-2021-21972.exe 127.0.0.1:8080")
		fmt.Println("CVE-2021-21972.exe https://127.0.0.1:8080")
		fmt.Println("CVE-2021-21972.exe -f target.txt")
	}
}
